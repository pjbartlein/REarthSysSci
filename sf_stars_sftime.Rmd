---
title: "sf / stars / sftime"
output: 
  html_document:
    fig_caption: no
    number_sections: yes
    toc: yes
    toc_float: False
    collapsed: no
---

```{r set-options, echo=FALSE}
options(width = 105)
knitr::opts_chunk$set(dev='png', dpi=300, cache=TRUE, out.width = "80%", out.height = "80%")
pdf.options(useDingbats = TRUE)
klippy::klippy(position = c('top', 'right'))
```
<span style="color: green;">**NOTE:&nbsp; This page has been revised for the 2024 version of the course, but there may be some additional edits.** &nbsp; <br>
  
# Introduction # 

In addition to the `terra` package, there are three other packages that are able to manage and analyze explicitly spatial and spatiotemporal data in R. These include

- `sf` ("simple features") -- the replacement for the original spatial `sp` package in R, that links directly with the `GEOS`, `GDAL`, and `PROJ` libraies, and thus enables a broad range of mapping (including projection and coordinate transformations), and the application of geospatial analyses to spatial data [[https://r-spatial.github.io/sf/index.html]](https://r-spatial.github.io/sf/index.html);
- `stars` -- an extension to `sf`, which explicity handles space-time data on regular grids (data cubes) (and is a replacement for the older `spacetime` package) [[https://r-spatial.github.io/stars/index.html]](https://r-spatial.github.io/stars/index.html); and 
- `sftime` also an extension to the `sf` package, which explicity includes a "time" variable [[https://r-spatial.org/r/2022/04/12/sftime-1.html]](https://r-spatial.org/r/2022/04/12/sftime-1.html).

Each of these packages has a typical application: for `sf`, general mapping and geospatial analyses, for `stars`, the analysis of data cubes like those generated by climate models, and for `sftime`, the analysis of data that are not necessarily on regular grids in time or space, like earthquake or paleoecological data. This is a really short introduction, the main reference is Pebesma, E. and R. Bivand, 2023, *Spatial Data Science with Applications in R* (CRC Press) [[https://r-spatial.org/book/]](https://r-spatial.org/book/).

The `sf` package supports well the reading and writing of "traditional" geospatial data formats, such as ESRI Shapefiles, which is demonstrated here by reading a shape file from the NaturalEarth collection [[https://www.naturalearthdata.com]](https://www.naturalearthdata.com). Load the libraries:

```{r}
library(sf)
library(stars)
library(terra)
library(tidyverse)
library(ggplot2)
library(RColorBrewer)
```

Read a previously downloade shape file:

```{r}
# world_sf
shapefile <- 
  "/Users/bartlein/Dropbox/DataVis/working/data/shp_files/ne_110m_admin_0_countries/ne_110m_admin_0_countries.shp"
world_sf <- st_read(shapefile)
```

Get the outline and plot it, and note the class of the `world_otl_sf` object

```{r}
# get the just the outline (i.e. the st_geometry)
world_otl_sf <- st_geometry(world_sf)
plot(world_otl_sf) 
class(world_otl_sf)
```

Here's a `ggplot2()` version of the world outline:

```{r}
# ggplot map of world_outline
ggplot() + 
  geom_sf(data = world_otl_sf, fill = NA, col = "black") + 
  scale_x_continuous(breaks = seq(-180, 180, 30)) +
  scale_y_continuous(breaks = seq(-90, 90, 30)) +
  coord_sf(xlim = c(-180, +180), ylim = c(-90, 90), expand = FALSE) +
  theme_bw()
```

`ggplot2` allows fine control of such things as graticule labeling, color scales, and so on.

# stars #

The `stars` package, like `terra` and `sf` can easily read and write netCDF files. Here, we'll look at a couple of "reanalysis" datasets consisting of 4-dimensional cubes of retrospective long-term means of climate data generated by observations and a reanalysis climate model, where the dimensions are *longitude by latitude by level by time* (and level refers to elevation in the atmosphere as represented by pressure, e.g. level 1 is at1000 hPa (i.e., the surface), level 6 is at 500 hPa (upper air)). 

## Read some data ##

Read the pressure-surface heights:

```{r cache = TRUE, message=FALSE, warning=FALSE}
# stars
nc_file <- "/Users/bartlein/Projects/RESS/data/nc_files/NCEP2_hgt.mon.ltm.1991-2020.nc"
hgt <- read_ncdf(nc_file, var = "hgt", proxy = FALSE)

# list some info
hgt
dim(hgt)
```

The time-dimension values in this data set are in the "time-since" format, which `read_ncdf()` interprets in a somewhat awkward year-month-day format. They can be replaced by text labels:

```{r}
# replace time dimension values
attr(hgt, "dimensions")$time$values <- 
  c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")
attr(hgt, "dimensions")$time$refsys <- "Name"
hgt
```
Plot the pressure-surface heights. Ignore the bounding-box warning.

```{r message=FALSE, warning=FALSE}
plot(hgt)
```

What seems to get plotted is the long-term means of one month at the different levels. Plot a single level, here level 6, or the 500 hPa level.

```{r message=FALSE, warning=FALSE}
plot(slice(hgt, level,  6)) # level = 6 is 500 hPa
```

Repeat for air temperature (`air` in this data set): 

```{r cache=TRUE, message=FALSE, warning=FALSE}
nc_file <- "/Users/bartlein/Projects/RESS/data/nc_files/NCEP2_air.mon.ltm.1991-2020.nc"
air <- read_ncdf(nc_file, var = "air", proxy = FALSE)
air
dim(air)

# replace time dimension values
attr(air, "dimensions")$time$values <- 
  c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")
attr(air, "dimensions")$time$refsys <- "Name"
air

plot(air)
plot(slice(air, level,  1)) # level 1 is 1000 hPa (surface)
```

## ggplot2 maps

`ggplot2` has a function `geom_stars()` that "knows" how to plot `stars` data objects: Here's a plot of 500 hPa (level 6) heights:

```{r out.width = "100%", out.height = "100%"}
# stars ggplots
ggplot() +
  geom_stars(data = slice(hgt, level, 6)) +
  geom_sf(data = world_otl_sf, fill = NA) +
  facet_wrap(~ time, nrow = 4, ncol = 3) +
  coord_sf(xlim = c(-180, +180), ylim = c(-90, 90), expand = FALSE) +
  scale_fill_distiller(palette = "PuOr") +
  theme_bw() + theme(strip.text = element_text(size = 6))
```

Here, the `stars` object was plotted first, followed by the world world outline. The `facet_wrap()` function controls the paneling, and the `expand = FALSE` argument of the `coord_sf()` function removes some of the white space between panels. The `theme(strip.text = element_text(size = 6))` function makes the "header" boxes and fonts a little smaller.

Here's the plot for near-surface air temperature:

```{r out.width = "100%", out.height = "100%"}
ggplot() +
  geom_stars(data = slice(air, level, 1)) + 
  geom_sf(data = world_otl_sf, fill = NA) +
  facet_wrap(~ time, nrow = 4, ncol = 3) +
  coord_sf(xlim = c(-180, +180), ylim = c(-90, 90), expand = FALSE) +
  scale_fill_distiller(palette = "RdBu") +
  theme_bw() + theme(strip.text = element_text(size = 6))
```

## Converting stars objects to terra and sf objects ##

`stars` objects, in particular 3-dimensional data cubes, can be easily converted to `terra` and `sf` objects (i.e. raster stacks, or `SpatRaster` objects in `terra` and in `sf`). To demonstrate this, get a single 3-d "slice" of air temperature from the 4-d cube:

```{r}
# get a single slice
class(air)
dim(air)
```
So `air` is a 4-d object.  Now get the slice (at 1000 hPa):

```{r}
air_1000 <- slice(air, level,  1)
class(air_1000)
air_1000
dim(air_1000)
```
Now convert that 3-d slice to `terra`

```{r}
# convert to SpatRaster
air_1000_sr <- as(air_1000, "SpatRaster") 
class(air_1000_sr)
air_1000_sr
```

Notice that the spatial extent is a little odd. We know from the original netCDF file that the western edge of the grid is at -180.0E, and the southern edge at -90.0N. The correct spatial exent can be restored like this:

```{r}
# restore spatial extent
ext(air_1000_sr) <- c(-180, 175, -90, 90)
```

The dataset, which is now a `terra` object, can be plotted as usual:

```{r}
panel(air_1000_sr, nc = 3, nr = 4)
```



