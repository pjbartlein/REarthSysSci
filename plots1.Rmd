---
title: "Plots (1)"
output: 
  html_document:
    fig_caption: no
    number_sections: yes
    toc: yes
    toc_float: false
    collapsed: no
---

```{r plots1-1, echo=FALSE}
options(width = 105)
knitr::opts_chunk$set(dev='png', dpi=300, cache=TRUE, out.width = "80%", out.height = "80%", verbose=TRUE)
pdf.options(useDingbats = TRUE)
klippy::klippy(position = c('top', 'right'))
```
<p><span style="color: #00cc00;">NOTE:  This page has been revised for Winter 2021, but may undergo further edits.</span></p>
# Introduction #

Once data has been retrieved and read in, the first step in any analysis is to plot or visualize the data: plot first, then model! The prinicipal plotting and visualization tool for examining Earth-system science data is, of course, the map, but there are a variety of other kinds of plots that are useful including time-space maps, or Hovm√∂ller diagrams. This topic focuses on some of the basic plots for characterizing data, and contrasts the quick (and dirty) base R plots with the nicer versions of plots generated by the `{ggplot2}` package. The original package was `{ggplot}`, and was replaced by. `{ggplot2}` (although the main function `ggplot()` remained the same). The current version of the package (as of Jan 2024), is 3.4.4, but it's still called `{ggplot2}` (and the main function remains `ggplot()`).

The package `{ggplot2}` by Hadley Wickham (and others) provides an alternative approach to the "base" graphics in **R** for constructing plots and maps, and was inspired by Lee Wilkinson's *The Grammar of Graphics* book (Springer, 2nd Ed. 2005).  The basic premise of the *Grammar of Graphics* book, and of the underlying design of the package, is that data graphics, like a language, are built upon some basic components that are assembled or layered on top of one another.  In the case of English (e.g Garner, B., 2016, *The Chicago Guide to Grammar, Usage and Punctuation*, Univ. Chicago Press), there are eight "parts of speech" from which sentences are assembled:

- *Nouns* (e.g. *computer*, *classroom*, *data*, ...), including gerunds (e.g. *readings*)
- *Pronouns* (e.g. *he*, *she*, *they*, ...)
- *Adjectives* (e.g. *good*, *green*, *my*, *year-to-year*, ..., including articles, e.g. *a*, *the*)
- *Verbs* (e.g. *analyze*, *write*, *discuss*, *computing*, ...)
- *Adverbs* (e.g. "-ly" words, *very*, *loudly*, *bigly*, *near*, *far*, ...)
- *Prepositions* (e.g. *on*, *in*, *to*, ...)
- *Conjunctives* (e.g. *and*, *but*, ...)
- *Interjections* (e.g. *damn*)

(but as Garner notes, those categories "aren't fully settled..." p. 18).

In the case of graphics (e.g. Wickham, H., 2016, *ggplot2 -- Elegant Graphics for Data Analysis, 2nd. Ed.*, Springer, available online from [[http://library.uoregon.edu]](http://library.uoregon.edu)) the components are:

- *Data* (e.g. in a dataframe)
- *Coordinate Systems* (the coordinate system of a plot)
- *Geoms* and their "aesthetic mappings" (the geometric objects like points, lines, polygons that represent the data)

These functions return *Layers* (made up of geometric elements) that build up the plot.  In addition, plots are composed of 

- *Stats* (or "statistical transformations", i.e. curves)
- *Scales* (that map data into the "aesthetic space", i.e. axes and legends)
- *Facets* (e.g subsets of data in individual plots)
- *Legends* and
- *Themes* (that control things like background colors, fonts, etc.)

In describing or characterizing the observations of an individual variable, there are three basic properties that are of interest:

- the *location* of observations (along the number line in general (but the geographical analogy is obvious), or how large or small the values of the individual observations are)
- the *dispersion* (sometimes called scale or spread) of the observations (how spread out they are along the number line, and again the geographical analogy is obvious)
-  the *distribution* of the observations (a characterization of the frequency of occurrence of different values of the variable--do some values occurs more frequently than other values?)

Univariate plots provide one way to find out about those properties (and univariate descriptive statistics provide another).

# Univariate and bivariate plots # 

There are two basic kinds of univariate, or one-variable-at-a-time plots, 

1. Enumerative plots, or plots that show every observation, and
2. Summary plots, that generalize the data into a simplified representation.  

## Simple plots ##

Load the `ggplot2` package:

```{r plots1-2 }
# ggplot2 versions of plots
library(ggplot2)
```

Also load some data to reproduce the examples here:


```{r plots1-3 }
# load data from a saved .RData file
con <- url("https://pages.uoregon.edu/bartlein/RESS/RData/geog490.RData")
load(file=con) 
```

We'll start with plots that are *univariate* (one variable) *enumerative* (all data points shown). (This page is largely derived from the GEOG 4/595 Geographic Data Analysis page [[https://pjbartlein.github.io/GeogDataAnalysis/]](https://pjbartlein.github.io/GeogDataAnalysis/). Enumerative plots, in which all observations are shown, have the advantage of not losing any specific information--the values of the individual observations can be retrieved from the plot.  The disadvantage of such plots arises when there are a large number of observations--it may be difficult to get an overall view of the properties of a variable.  Enumerative plots do a fairly good job of displaying the location, dispersion and distribution of a variable, but may not allow a clear comparison of variables, one to another.

Here is the **R** base graphics simple index plot, with the value of the variable being plotted on the y axis, and the row number in the data.frame on the x-axis (and note the use of the `attach()` function to make the variables available using just their names, as opposed ot "full names" (e.g. `Length` as opposed to `sumcr$Length`):

```{r plots1-4 }
# index plot
attach(sumcr)
plot(Length)
```

Here's the `{ggplot2}` version of the same plot. The code is longer, but the additions allow for greater control, with the plot being built up in layers. The easiest way to see how the plots work is to comment out one or more lines (after the first) to see how the plots work.

```{r plots1-5 }
# ggplot version
ggplot() + 
  geom_point(data = sumcr, aes(x = 1:nrow(sumcr), y = Length)) +
  geom_line(aes(x = 1:nrow(sumcr), y = Length)) +
  labs(title="Summit Cr.", x = "Observation", y = "Length (m)") +
  theme_bw() 
```

Another common univariate enumerative plot is the the strip plot / chart, plain and stacked:

```{r plots1-6 }
# stripchart
stripchart(Length)
stripchart(Length, method="stack")
```

The full `ggplot2()` almost reproduces the base-graphics version.  Note the use of the `aes()` (aesthetic) function for describing the basic plot, which then has the dotplot added using the `geom_dotplot()` function.  The `theme_bw()` term specifies the simple black-and-white theme.  As in the case of a histogram, the `binwidth` parameter controls the granularity of the plot, and `coord_fixed()` function changes the aspect ratio of the plot.  (The white space can be cropped when saving the image.)

```{r plots1-7 }
# ggplot stripchart
ggplot(data=sumcr, aes(x = Length)) + 
  geom_dotplot(binwidth = 0.25, method = "histodot") + 
  coord_fixed(ratio = 4.0)
```

Note that the whitespace could be removed after saving the figure.

## Dotcharts/Dotplots ##

"Cleveland-style" dot charts are named after their inventor, William S. Cleveland, who wrote a couple of influential books on datea visualization, and participated in the development of S at Bell Labs. They were designed as an antidote to bar and pie charts, which are notorious for their poor performance in delivering information. Here's a base-graphics Cleveland-style dotchart.

```{r plots1-8 }
# Cleveland-style dot charts
dotchart(WidthWS, labels=as.character(Location), cex=0.5)
```

... and the `ggplot2` equivalent:

```{r plots1-9 }
ggplot(sumcr, aes(x=WidthWS, y=Location)) + geom_point(size=1) 
ggplot(sumcr, aes(x=WidthWS, y=Location)) + geom_point(size=1) + theme_bw()
```

Note the subtle difference produced by the use of the `theme_bw()` term.  The plots are basically x-y plots (specified by the `aes(x=WidthWS, y=Location)` arguments), with the points themselves added by the `geom_point()` term.

An alternative version of this plot, and the one most frequently used, can be constructed by sorting the rows of the data table.  Sorting can be tricky--it is easy to completely destroy a data set by sorting one variable and not the others.  It is often better to leave the data unsorted, and to use an auxiliary variable (in this case `index`) to record the rank-order of the variable being plotted (in this case `WidthWS`), and the explicit vector-element indexing of R (square brackets) to arrange the data in the right order:

Here's the dotchart, with rows ordered by the `WidthWS` values:

```{r plots1-10 }
# sorted dotchart
index <- order(WidthWS)
dotchart(WidthWS[index], labels=as.character(Location[index]), cex=0.5)
```

... and the `ggplot2` equivalent--note the use of the `theme()` term to modify the label size:

```{r plots1-11 }
ggplot(sumcr, aes(x=WidthWS, y=reorder(Location, WidthWS))) + 
  geom_point(size=1) + 
  theme(axis.text.y = element_text(size=4, face="italic"))
```

## Boxplots ##

Summary plots display an object or a graph that gives a more concise expression of the location, dispersion, and distribution of a variable than an enumerative plot, but this comes at the expense of some loss of information:  In a summary plot, it is no longer possible to retrieve the individual data value, but this loss is usually matched by the gain in understanding that results from the efficient representation of the data. Summary plots generally prove to be much better than the enumerative plots in revealing the distribution of the data.  

Boxplots are an example of a *univariate* and *summary* plot. Here is the standard boxplot:

```{r plots1-12 }
# Boxplot
boxplot(WidthWS ~ HU, range=0)
```

... and the `{ggplot2}` version:


```{r plots1-13 }
ggplot(data = sumcr, aes(x=HU, y=WidthWS)) + geom_boxplot() + theme_bw()
```

The actual data points can be added to the boxplot, by specifying an additional graphical element using the `geom_point()` function

```{r plots1-14 }
# ggplot box and points
ggplot(sumcr, aes(x=HU, y=WidthWS)) + 
  geom_boxplot() +
  geom_point(colour = "blue") 
```
Detach the `sumcr` dataframe.

```{r plots1-15 }
detach(sumcr)
```

## Histograms and density plots ##

Histograms are a type of bar chart that displays the counts or relative frequencies of values falling in different class intervals or ranges.  The overall impression one gets about the distribution of a variable depends somewhat on the way the histogram is constructed:  fewer bars give a more generalized view, but may obscure details of the distribution (the existence of a bimodal distribution, for example), while more may not generalize enough.  

```{r plots1-16 }
# histograms
# attach(specmap)
hist(specmap$O18, breaks=20)
```

Here's the `ggplot2` version, with the biwidth specified explicitly (e.g., 1.0)

```{r plots1-17 }
ggplot(specmap, aes(x = O18)) + 
  geom_histogram(binwidth = 0.1, fill = "white", color = "red", boundary = 0.05)
```

The look of a histogram depends a lot on the choice of bin-widths, and the impression one may have about the distribution of the data is influenced by the "spikiness" of the data. An alternative is the density plot -- a plot of the local relative frequency or density of points along the number line or x-axis of a plot.  The local density is determined by summing the individual "kernel" densities for each point.  Where points occur more frequently, this sum, and consequently the local density, will be greater.  Density plots get around some of the problems that histograms have, but still require some choices to be made. Here's a base-graphics density plot:

```{r plots1-18 }
# density plots
O18_density <- density(specmap$O18)
plot(O18_density)
```
Note that in this example, an object `O18.density` is created by the `density()` function, and then plotted using the `plot()` function.

Here's a version the `ggplot2` density plot:

```{r plots1-19 }
ggplot(specmap, aes(x = O18)) + geom_density() + ylim(0.0, 0.5)
```

A combined histogram, density and rug plot via the base graphics:

```{r plots1-20 }
hist(specmap$O18, breaks=20, probability=TRUE)
lines(O18_density)
rug(specmap$O18)
```

And here's a `ggplot` version, with three distinct layers:

```{r plots1-21 }
ggplot(specmap, aes(x = O18)) + 
  geom_histogram(binwidth = 0.1, fill = "white", color = "red", boundary = 0.05) + 
  geom_line(stat = "density") +
  geom_rug(data = specmap, aes(x = O18)) 
```

[[Back to top]](plots1.html)

# Bivariate plots #

Bivariate descriptive displays or plots are designed to reveal the relationship between two variables.  As was the case when examining single variables, there are several basic characteristics of the relationship between two variables that are of interest.  These include:

- the *form* of the relationship
- the *strength* of the relationship, and 
- the *dependence* of the relationship on external (to the two variables being examined) circumstances.

Bivariate plots provide the means for characterizing pair-wise relationships between variables.  Some simple extensions to such plots, such as presenting multiple bivariate plots in a single diagram, or labeling the points in a plot, allow simultaneous relationships among a number of variables to be viewed.

## Scatter diagrams ##

The scatter diagram is *the* workhourse diagram for looking at relationships between variables (which is why it is the default plot method in R). Also known as scatter plots or x-y plots, they are *bivariate* (two variables) and *enumerative* (every point shown). Traditionally the dependent or response variable is plotted on the vertical or Y-axis, while the "independent or predictor variable is plotted on the horizontal or X-axis.  The convention can be imposed on plots in by listing the horizontal or X-axis variable first, and Y-axis variable second (i.e., an X-Y plots).

Here's the base plot version of a scatter diagram:

```{r plots1-22 }
# scatter plots
# use Oregon climate-station data 
attach(orstationc)
plot(elev,tann)
```

... and here are two `{ggplot2}` scatter plots of annual temperature and annual precipitation vs. elevation:

```{r plots1-23 }
# ggplot2 scatter diagrams
ggplot(orstationc, aes(x = elev, y = tann)) + geom_point()
ggplot(orstationc, aes(x = elev, y = pann)) + geom_point()
```

It might make sense to compare the plots side-by-side. That can be done for the `ggplot2` versions of those plots cby generating the plots, saving them as objects (`plot1` and `plot2`), and then using a function `grid.arrange()` from the `gridExtra` package to plot the two objects:

```{r plots1-24 }
library(gridExtra)
plot1 <- ggplot(orstationc, aes(x = elev, y = tann)) + geom_point()
plot2 <- ggplot(orstationc, aes(x = elev, y = pann)) + geom_point()
grid.arrange(plot1, plot2, ncol=2)
```

Note that `ggplot2` allows one to transform the coordinate system as well as the values of the individual variables.  Here a square-root scaling of the y-axis is done, to examine the relationship between precipitation and elevation, when the precipitation values have been transformed in an attempt to make the relationship more linear.  Note that the overall appearance of the plots is identical--it's the y-axes that differ.

```{r plots1-25 }
plot1 <- ggplot(orstationc, aes(x = elev, y = tann)) + geom_point()
plot2 <- ggplot(orstationc, aes(x = elev, y = pann)) + coord_trans(y="sqrt") + geom_point()
grid.arrange(plot1, plot2, ncol=2)
```

Labeling of points using `ggplot` is possible, and again `ggplot2()` offers more fine control, such as some ability to deal with text overlap.

Here is the base plotting version of a text-labelled scatter plot:

```{r plots1-26 }
plot(orstationc$tann ~ orstationc$elev, type="n")
text(orstationc$tann ~ orstationc$elev, labels=as.character(orstationc$station), cex = 0.8) # text
```

A `ggplot` version of the same ia shown below.  The `check_overlap()` function attempts to move the labels to avoid overplotting.  To see where the datapoints actualy lie, they are added as dots.

```{r plots1-27 }
ggplot(orstationc, aes(x= elev, y = tann, label=as.character(station))) +
  geom_text(check_overlap = TRUE, size = 3) +
  geom_point(size = 0.5) + 
  theme_gray()
```

Here's another approach to point-labeling:

```{r plots1-28 }
ggplot(orstationc, aes(x= elev, y = tann, label=as.character(station))) +
  geom_label(size = 3) + 
  # geom_point(size = 1, color = "red") +
  theme_gray()
```

Note the difference between the plots--the first plots a simple text string using `geom_text()` while the second plots a more formal label using `geom_label()`.

```{r plots1-29 }
detach(orstationc)
```

## Summarizing scatter plots ##

Although the visual inspection of a scatter plot generally reveals the nature of the relationship between the pair of variables being plotted, sometimes this relationship may be obscured simply by the number of points on the plot.  In such cases the relationship, if present, may be detected by a summarization method.  Similarly, our tendency to seek order in a chaotic set of points may lead us to perceive a relationship where none is really there.  Again, summarizing the scatter plot may be useful.

Scatter plot smoothing involves fitting a smoothed curve through the cloud of points to describe the general relationship between variables.  This technique is very generalizable, and a variety of smoothers can be used.  The most common is the "lowess" or "loess" smoother, which will be discussed in more detail later.

```{r plots1-30 }
# use Oregon climate station annual temperature data 
attach(ortann)
plot(elevation, tann)
lines(lowess(elevation,tann))
```

The `ggplot2` version uses `stat_smooth()` to get the lowess curve (and confidence band):

```{r plots1-31 }
# ggplot scatter plot plus smooth
ggplot(data = ortann, aes(x = elevation, y = tann)) + 
  geom_point() + 
  stat_smooth(span = 0.9) +
  theme_bw()
```

```{r plots1-32 }
detach(ortann)
```
[[Back to top]](plots1.html)

# Multivariate plots #

## Labelled scatter plots #

In addition to the simple catagorial (or factor) labelling of plots, the `{ggplot2}` package supports more elaborate, or computed, decoration or coloring of plots, in order to examine the role of additional variables on bivariate relationships. Annotation of points involves adding information to a plot for individual points, that include such things as the observation number or other information, to "explain" individual points that may be unusual, or to simply identify the point for a key observation or set of observations.

Here's the base R version of the specmap data.  Recall that the relationship between ice volume and insolation anomalies (or differences from the present day, which are considered to be the pacemake of the ice ages) is weak when examined superficially. 

```{r plots1-33 }
attach(specmap)
plot(O18 ~ Insol, pch=16, cex=0.6)
cor(O18, Insol)
```

 As we saw earlier, on approach is to look at the time series plot of O18 values, and use insolation to colorize the individual points.
 
```{r plots1-34 }
library(RColorBrewer)
library(classInt) # class-interval recoding library
# first block -- setup
plotvals <- Insol
nclr <- 8
plotclr <- brewer.pal(nclr,"PuOr")
plotclr <- plotclr[nclr:1] # reorder colors
class <- classIntervals(plotvals, nclr, style="quantile")
colcode <- findColours(class, plotclr)

# second block -- plot
plot(O18 ~ Age, ylim=c(2.5,-2.5), type="l")
points(O18 ~ Age, pch=16, col=colcode, cex=1.5)
```

Here's a `ggplot2` version, where the colorization is extended to the lines as well as the symbols.

```{r plots1-35 }
ggplot() + 
  geom_line(data = specmap, aes(x=Age, y=O18, color=Insol)) +
  geom_point(data = specmap, aes(x=Age, y=O18, color=Insol), size = 3) +  
  scale_y_reverse() + 
  scale_colour_gradientn(colours=rev(brewer.pal(nclr,"PuOr")))
```

As we saw earlier, positive insolation anomalies are associated with trends toward lower ice volume (negative O18 values, note the y-axis labelling), and negative anomalies with increasing ice volume.

```{r plots1-36 }
detach(specmap)
```

Symbol color and shape can be used to encode the values of two additional variables, as demonstrated using the Summit Cr. data:

```{r plots1-37 }
attach(sumcr)
plot(WidthWS ~ CumLen, pch=as.integer(Reach), col=as.integer(HU))
legend(25, 2, c("Reach A", "Reach B", "Reach C"), pch=c(1,2,3), col=1)
legend(650, 2, c("Glide", "Pool", "Riffle"), pch=1, col=c(1,2,3))
```

Here is the `ggplot2` version:

```{r plots1-38 }
# ggplot2 version
ggplot(sumcr, aes(x=CumLen, y=WidthWS, shape=Reach, color=HU)) + geom_point(size = 3)
```

```{r plots1-39 }
detach(sumcr)
```

Symbol size can be used to indicate the value of a third variable, forming a "bubble" or "balloon" plot, to indicate the value of station elevation on a simple longitude by latitude plot of the Oregon climate-station data:

```{r plots1-40 }
# bubble plot
plot(orstationc$lon, orstationc$lat, type="n")
symbols(orstationc$lon, orstationc$lat, circles=orstationc$elev, inches=0.1, add=T)
```

Here's the equivalent plot using `ggplot2`

```{r plots1-41 }
# ggplot version
ggplot() + 
  geom_sf(data = orcounty_sf, fill = NA) +
  geom_point(data = orstationc, aes(x=lon, y=lat, size=elev), shape=21, color="black", fill="lightblue") +
  coord_sf(xlim = c(-125, -116), ylim = c(41, 47), expand = FALSE) +
  theme_bw()

```

[[Back to top]](plots1.html)
